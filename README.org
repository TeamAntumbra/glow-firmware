#+options: html-postamble:nil

* Hardware

** Chip configuration

| lfuse |       0xff |
| hfuse |       0x9e |
| efuse | 0xc8(0xf8) |
| lock  |       0xff |

** Pins

| PB1(SCLK) | ISP header: SCK       |
| PB2(MOSI) | ISP header: MOSI      |
| PB3(MISO) | ISP header: MISO      |
| PB5(OC1A) | LED red channel FET   |
| PB6(OC1B) | LED green channel FET |
| PB7(OC1C) | LED blue channel FET  |
| PE2(~HWB) | Bootloader switch     |

* Flashing device firmware

** Firmware files

Download a =rawtumbra= build from [[https://dev.antumbra.io/build/rawtumbra/]]. This
is a tar archive containing the following:

- Bootloader firmware in Intel HEX format (~loader.hex~)
- Application firmware in Intel HEX (~main.hex~) and raw binary (~main.bin~)
  format
- Combined bootloader and application firmware in Intel HEX format
  (~combined.hex~)
- EEPROM contents (~default.eep~ and ~combined.eep~)

** Initial flashing

The commands given use ~avrdude~ with the AVR Dragon. Some versions of ~avrdude~
ship without a device definition for the ~atmega16u4~, so one must be provided.
Save the following as ~m16u4.conf~:

#+begin_src fundamental
  # This was copied wholesale from the m32u4 definition and modified only where
  # necessary to make programming the m16u4 work. It may be incomplete.

  #------------------------------------------------------------
  # ATmega16u4
  #------------------------------------------------------------

  part
      id               = "m16u4";
      desc             = "ATmega16U4";
      signature        = 0x1e 0x94 0x88; /* custom! 16u4 */
      usbpid           = 0x2ff4;
      has_jtag         = yes;
  #    stk500_devcode   = 0xB2;
  #    avr910_devcode   = 0x43;
      chip_erase_delay = 9000;
      pagel            = 0xD7;
      bs2              = 0xA0;
      reset            = dedicated;
      pgm_enable       = "1 0 1 0  1 1 0 0    0 1 0 1  0 0 1 1",
                         "x x x x  x x x x    x x x x  x x x x";

      chip_erase       = "1 0 1 0  1 1 0 0    1 0 0 0  0 0 0 0",
                         "x x x x  x x x x    x x x x  x x x x";

      timeout     = 200;
      stabdelay       = 100;
      cmdexedelay     = 25;
      synchloops      = 32;
      bytedelay       = 0;
      pollindex       = 3;
      pollvalue       = 0x53;
      predelay        = 1;
      postdelay       = 1;
      pollmethod      = 1;

      pp_controlstack     =
          0x0E, 0x1E, 0x0F, 0x1F, 0x2E, 0x3E, 0x2F, 0x3F,
          0x4E, 0x5E, 0x4F, 0x5F, 0x6E, 0x7E, 0x6F, 0x7F,
          0x66, 0x76, 0x67, 0x77, 0x6A, 0x7A, 0x6B, 0x7B,
          0xBE, 0xFD, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00;
      hventerstabdelay    = 100;
      progmodedelay       = 0;
      latchcycles         = 5;
      togglevtg           = 1;
      poweroffdelay       = 15;
      resetdelayms        = 1;
      resetdelayus        = 0;
      hvleavestabdelay    = 15;
      chiperasepulsewidth = 0;
      chiperasepolltimeout = 10;
      programfusepulsewidth = 0;
      programfusepolltimeout = 5;
      programlockpulsewidth = 0;
      programlockpolltimeout = 5;

      idr                 = 0x31;
      spmcr               = 0x57;
      rampz               = 0x3b;
      allowfullpagebitstream = no;

      ocdrev              = 3;

      memory "eeprom"
          paged           = no; /* leave this "no" */
          page_size       = 4;  /* for parallel programming */
          size            = 512; /* custom! 16u4 */
          min_write_delay = 9000;
          max_write_delay = 9000;
          readback_p1     = 0x00;
          readback_p2     = 0x00;
          read            = "  1   0   1   0      0   0   0   0",
                            "  x   x   x   x      x a10  a9  a8",
                            " a7  a6  a5  a4     a3  a2  a1  a0",
                            "  o   o   o   o      o   o   o   o";

          write           = "  1   1   0   0      0   0   0   0",
                            "  x   x   x   x      x a10  a9  a8",
                            " a7  a6  a5  a4     a3  a2  a1  a0",
                            "  i   i   i   i      i   i   i   i";

      loadpage_lo = "  1   1   0   0      0   0   0   1",
                "  0   0   0   0      0   0   0   0",
                "  0   0   0   0      0  a2  a1  a0",
                "  i   i   i   i      i   i   i   i";

      writepage   = "  1   1   0   0      0   0   1   0",
                "  0   0   x   x      x a10  a9  a8",
                " a7  a6  a5  a4     a3   0   0   0",
                "  x   x   x   x      x   x   x   x";

      mode        = 0x41;
      delay       = 20;
      blocksize   = 4;
      readsize    = 256;
        ;

      memory "flash"
          paged           = yes;
          size            = 16384; /* custom! 16u4 */
          page_size       = 128;
          num_pages       = 128; /* custom! 16u4 */
          min_write_delay = 4500;
          max_write_delay = 4500;
          readback_p1     = 0x00;
          readback_p2     = 0x00;
          read_lo         = "  0   0   1   0      0   0   0   0",
                            "  0 a14 a13 a12    a11 a10  a9  a8",
                            " a7  a6  a5  a4     a3  a2  a1  a0",
                            "  o   o   o   o      o   o   o   o";

          read_hi         = "  0   0   1   0      1   0   0   0",
                            "  0 a14 a13 a12    a11 a10  a9  a8",
                            " a7  a6  a5  a4     a3  a2  a1  a0",
                            "  o   o   o   o      o   o   o   o";

          loadpage_lo     = "  0   1   0   0      0   0   0   0",
                            "  x   x   x   x      x   x   x   x",
                            "  x   x  a5  a4     a3  a2  a1  a0",
                            "  i   i   i   i      i   i   i   i";

          loadpage_hi     = "  0   1   0   0      1   0   0   0",
                            "  x   x   x   x      x   x   x   x",
                            "  x   x  a5  a4     a3  a2  a1  a0",
                            "  i   i   i   i      i   i   i   i";

          writepage       = "  0   1   0   0      1   1   0   0",
                            " a15 a14 a13 a12    a11 a10  a9  a8",
                            " a7  a6   x   x      x   x   x   x",
                            "  x   x   x   x      x   x   x   x";

      mode        = 0x41;
      delay       = 6;
      blocksize   = 128;
      readsize    = 256;
        ;

      memory "lfuse"
          size            = 1;
          write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 0 0 0",
                            "x x x x  x x x x  i i i i  i i i i";

          read            = "0 1 0 1  0 0 0 0  0 0 0 0  0 0 0 0",
                            "x x x x  x x x x  o o o o  o o o o";
          min_write_delay = 9000;
          max_write_delay = 9000;
        ;

      memory "hfuse"
          size            = 1;
          write           = "1 0 1 0  1 1 0 0  1 0 1 0  1 0 0 0",
                            "x x x x  x x x x  i i i i  i i i i";

          read            = "0 1 0 1  1 0 0 0  0 0 0 0  1 0 0 0",
                            "x x x x  x x x x  o o o o  o o o o";
          min_write_delay = 9000;
          max_write_delay = 9000;
        ;

      memory "efuse"
          size            = 1;
          write           = "1 0 1 0  1 1 0 0  1 0 1 0  0 1 0 0",
                            "x x x x  x x x x  x x x x  i i i i";

          read            = "0 1 0 1  0 0 0 0  0 0 0 0  1 0 0 0",
                            "x x x x  x x x x  o o o o  o o o o";
          min_write_delay = 9000;
          max_write_delay = 9000;
        ;

      memory "lock"
          size            = 1;
          read            = "0 1 0 1  1 0 0 0   0 0 0 0  0 0 0 0",
                            "x x x x  x x x x   x x o o  o o o o";

          write           = "1 0 1 0  1 1 0 0   1 1 1 x  x x x x",
                            "x x x x  x x x x   1 1 i i  i i i i";
          min_write_delay = 9000;
          max_write_delay = 9000;
        ;

      memory "calibration"
          size            = 1;
          read            = "0 0 1 1  1 0 0 0    x x x x  x x x x",
                            "0 0 0 0  0 0 0 0    o o o o  o o o o";
        ;

      memory "signature"
          size            = 3;
          read            = "0  0  1  1   0  0  0  0   x  x  x  x   x  x  x  x",
                            "x  x  x  x   x  x a1 a0   o  o  o  o   o  o  o  o";
        ;
    ;
#+end_src

Each ~avrdude~ command line starts the same way. For brevity, ~$CMDLINE~ has
been substituted for the following:

: avrdude -C +m16u4.conf -c dragon_isp -P usb -p atmega16u4

If the chip is fresh from the factory, it probably shipped with the lock bits
programmed. This causes the flashing process to fail. Clear the lock bits by
executing a chip erase. (~-B 10~ is used because the chip is set for a low clock
frequency by default.)

: $CMDLINE -B 10 -e

Set the configuration fuses:

: $CMDLINE -B 10 -U lfuse:w:0xFF:m -U hfuse:w:0x9E:m -U efuse:w:0xC8:m

The highest clock frequency is now configured, and faster programming speeds can
be used in subsequent commands.

*** Bootloader by ISP, application by USB

Flash bootloader and EEPROM:

: $CMDLINE -B 0.5 -U flash:w:loader.hex:i -U eeprom:w:default.eep:r

Use ~antumbratool~ to flash the main application:

: antumbratool flash-write main.bin
: antumbratool boot-set main
: antumbratool reset

*** Bootloader and application together by ISP

This method will be used in mass production.

Flash bootloader, application, and EEPROM. ~combined.eep~ must be used in place
of ~default.eep~ because it tells the bootloader that an application has already
been flashed. The two EEPROM files are otherwise identical.

: $CMDLINE -B 0.5 -U flash:w:combined.hex:i -U eeprom:w:combined.eep:r

** Reflashing application firmware

Use ~antumbratool~:

: antumbratool boot-set loader
: antumbratool reset
: antumbratool flash-write main.bin
: antumbratool boot-set main
: antumbratool reset

* Protocol

Glow devices speak a simple, extensible protocol over USB. No USB class,
subclass, or protocol is used; communication occurs directly with raw endpoints.

** Device identification

To be recognized as implementing the Glow protocol, a device must conform to a
number of conditions. First, it must have one of the following combinations of
vendor and product ID:

| Vendor ID | Product ID |                                  |
|-----------+------------+----------------------------------|
|    0x2040 |     0x03eb | LUFA test ID (experimental only) |

Only the first interface (bInterfaceNumber = 0) of the default configuration
(bConfigurationValue = 1) is used. bInterfaceClass, bInterfaceSubClass, and
bInterfaceProtocol must all be 0xff. The iInterface string descriptor must be of
this form:

: io.antumbra.glowapi/<outep>/<inep>/<info>

- =io.antumbra.glowapi=: identifies this interface as implementing the Glow
  protocol described here
- =<outep>=: bEndpointAddress of the OUT (host to device) command endpoint
- =<inep>=: bEndpointAddress of the IN (device to host) command endpoint
- =<info>=: an arbitrary string, but recommended to be in a form that identifies
  the implementation (such as =org.example.glow-compatible-device= reverse
  domain name notation)

=<outep>= and =<inep>= are two-digit hexadecimal numbers with no prefix. Both
lowercase and uppercase digits are acceptable, but lowercase is recommended for
consistency. The high bit of =<outep>= must be 0 and the high bit of =<inep>=
must be 1; these bits indicate the endpoint direction. Typically =<outep>= is
=01= and =<inep>= is =82=.

Both must be bulk endpoints. There may be other endpoints than those specified
by =<outep>= and =<inep>=, but they are ignored unless the device advertises an
API that uses them (see below).

** Base protocol

The required bulk endpoints are used to carry a packet-based command protocol.
The host sends commands to the device, and the device must respond to each
command.

Commands are specified by an API identifier and a command identifier. The API
identifier represents a set of functionality, and the command identifier
represents a specific operation within that set.

All packets are of fixed 64-byte size. Where applicable, big-endian order is
assumed.

Command packet:

| Field     | Size |                           |
|-----------+------+---------------------------|
| api       |    4 | API identifier            |
| cmd       |    2 | Command identifier        |
| (padding) |    2 | Ignored                   |
| data      |    N | Arbitrary, defined by API |
| (padding) | 56-N | Ignored                   |

Response packet:

| Field     | Size |                           |
|-----------+------+---------------------------|
| status    | 1    | (see below)               |
| (padding) | 7    | Ignored                   |
| data      | N    | Arbitrary, defined by API |
| (padding) | 56-N | Ignored                   |

The device must respond to commands in the order that they were received. The
host should wait until the response is received before sending additional
commands.

The =status= field indicates protocol-level errors:

| Status |                            |
|--------+----------------------------|
|      0 | Success                    |
|      1 | Unsupported API or command |

APIs may not use the =status= field for their own purposes. If it is necessary
to represent the occurence of an API-level error, this must be done in the
response payload. The =status= field exists at a different conceptual layer.

Responses with nonzero =status= have an empty payload.

** Core API

All devices must support the Core API. It provides universal functionality and
allows bootstrapping support for other APIs.

The API identifier is 0.

*** Echo (0)

Can be used to synchronize the host and device at the beginning of a session, in
case the device is still in the process of sending responses from a previous
session. For this application, the host should send an Echo command with a
reasonably unique payload and discard response packets until it receives one
with the same payload as the command.

The command payload contains arbitrary data and is assumed to occupy the maximum
available space in the packet. The response payload is equal to the command
payload.

*** Ask (1)

Ask whether the device supports a given API.

Command payload:

| Field | Size |                                           |
|-------+------+-------------------------------------------|
| api   |    4 | API identifier for which to query support |

Response payload:

| Field     | Size |                                                   |
|-----------+------+---------------------------------------------------|
| supported | 1    | 1 if API is supported, else 0                     |
| info      | N    | API-defined information, if supported; else empty |

If the host queries API 0 (Core), the device must respond with affirmative
support. No =info= field is defined for this case.

*** Diagnostic (2)

Report problem conditions such as hardware failures, configuration errors, etc.

The command payload is empty.

The response payload contains arbitrary data of a format specific to the device
firmware. However, the presence of any nonzero byte in the payload will be
assumed to indicate the existence of at least one problem condition.

*** Implementation ID (3)

Produce human-readable information that identifies the device implementation. A
reverse domain name is one possible form.

The command payload is empty.

The response payload is a human-readable string of up to 56 bytes in an
unspecified encoding. If its length is less than 56 bytes, there must be a 0
byte immediately after the end of the string. Payload data after the 0 byte is
ignored.

*** Device ID (4)

Produce an identifier for this particular device that may be reasonably assumed
to distinguish it from others of its model and all other Glow protocol devices
in existence.

The command payload is empty.

The response payload contains the 56-byte unique identifier.

*** Reset (5)

Perform a full hardware reset.

The command payload is empty.

The response payload is empty.

* APIs

** Boot Control (1)

The Glow includes a firmware bootloader that can be used to update the main
application without a flash programmer. While the bootloader can be activated at
power-on by shorting pads on the board, it is often necessary to activate the
bootloader without physical intervention. This API controls bootloader startup
purely through software.

The API identifier is 1.

*** Set Boot (0)

Select whether the bootloader or the main application will be started at
power-on.

The command payload is one byte. If the byte is zero, the main application will
be started at power-on; if the byte is nonzero, the bootloader will be started.
This setting is persistent and remains in effect until explicitly modified.
Hardware boot switches, if applicable, override this setting.

The response payload is empty.

** EEPROM (2)

This API allows access to the device's onboard byte-addressable nonvolatile data
memory.

The API identifier is 2.

*** EEPROM Info (0)

Report EEPROM size.

The command payload is empty.

Response payload:

| Field | Size |                     |
|-------+------+---------------------|
| size  |    2 | EEPROM size (bytes) |

*** EEPROM Read (1)

Read a variable-size block from EEPROM.

Command payload:

| Field  | Size |                                |
|--------+------+--------------------------------|
| offset |    2 | Start offset to read (bytes)   |
| length |    1 | Length to read (bytes); max 48 |

Response payload:

| Field     |   Size |                          |
|-----------+--------+--------------------------|
| status    |      1 | Indicate error condition |
| (padding) |      7 | Ignored                  |
| data      | max 48 | (if successful)          |

If the specified region is out of bounds (=offset= + =length= > size given by
=EEPROM Info=) or otherwise unacceptable, an error code is returned:

| Code |                                                |
|------+------------------------------------------------|
|    0 | Success                                        |
|    1 | Out of EEPROM bounds                           |
|    2 | Specified =length= too large for packet format |

*** EEPROM Write (2)

Write a variable-size block to EEPROM.

Command payload:

| Field     |   Size |                                 |
|-----------+--------+---------------------------------|
| offset    |      2 | Start offset to write (bytes)   |
| length    |      1 | Length to write (bytes); max 48 |
| (padding) |      5 | Ignored                         |
| data      | max 48 | Block to write                  |

Response payload:

| Field  | Size |                          |
|--------+------+--------------------------|
| status |    1 | Indicate error condition |

=status= is as specified in =EEPROM Read=.

** Flash (3)

This API allows access to the device's page-based nonvolatile program memory.

Since flash pages are generally much larger than packets, I/O occurs in two
stages using a page-sized intermediate buffer. To read a page, one command dumps
the page into the buffer, and the buffer contents are then read out over
multiple commands. To write a page, the buffer contents are loaded over multiple
commands, and a final command writes the page to flash.

Before the buffer has been fully populated, its contents are undefined. The read
and write commands are assumed to share the same buffer, so they should not be
interleaved.

*** Flash Info (0)

Report flash size.

The command payload is empty.

Response payload:

| Field    | Size |                            |
|----------+------+----------------------------|
| pagesize |    2 | Size of flash pages/buffer |
| numpages |    4 | Number of flash pages      |

*** Flash Buffer Read (1)

Read a variable-size block from page buffer.

Command payload:

| Field  | Size |                        |
|--------+------+------------------------|
| offset |    2 | Start offset to read   |
| length |    1 | Length to read; max 48 |

Response payload:

| Field     |   Size |                          |
|-----------+--------+--------------------------|
| status    |      1 | Indicate error condition |
| (padding) |      7 | Ignored                  |
| data      | max 48 | (if successful)          |

If the specified region is out of bounds or otherwise unacceptable, an error
code is returned:

| Code |                                                |
|------+------------------------------------------------|
|    0 | Success                                        |
|    1 | Out of buffer bounds                           |
|    2 | Specified =length= too large for packet format |

*** Flash Buffer Write (2)

Write a variable-size block to page buffer.

Command payload:

| Field     |   Size |                         |
|-----------+--------+-------------------------|
| offset    |      2 | Start offset to write   |
| length    |      1 | Length to write; max 48 |
| (padding) |      5 | Ignored                 |
| data      | max 48 | Block to write          |

Response payload:

| Field  | Size |                          |
|--------+------+--------------------------|
| status |    1 | Indicate error condition |

=status= is as specified in =Flash Buffer Read=.

*** Flash Page Read (3)

Load flash page into buffer.

Command payload:

| Field     | Size |                             |
|-----------+------+-----------------------------|
| pageindex |    4 | Index of flash page to load |

Response payload:

| Field  | Size |                          |
|--------+------+--------------------------|
| status |    1 | Indicate error condition |

If the specified page index is out of bounds, =status= is set to 1. Otherwise,
it is set to 0.

*** Flash Page Write (4)

Write page buffer to flash.

| Field     | Size |                              |
|-----------+------+------------------------------|
| pageindex |    4 | Index of flash page to write |

Response payload:

| Field  | Size |                          |
|--------+------+--------------------------|
| status |    1 | Indicate error condition |

=status= is as specified in =Flash Page Read=.

** Light (4)

This API controls a single RGB LED. The color is not set directly through this
API for performance reasons; instead, colors are streamed to a dedicated USB
endpoint.

*** Get Endpoint (0)

Produce the address of the USB endpoint for color streaming.

The command payload is empty.

Response payload:

| Field    | Size |                  |
|----------+------+------------------|
| endpoint |    1 | endpoint address |

The endpoint address must refer to a bulk OUT endpoint (high bit 0). It expects
6-byte single-packet transfers with the following structure:

| Field | Size |                 |
|-------+------+-----------------|
| red   |    2 | red component   |
| green |    2 | green component |
| blue  |    2 | blue component  |

A component value shall affect the LED brightness as though that LED component
is driven by PWM and the component value is proportional to the duty cycle. A
value of 65535 indicates maximum brightness (which may be less than 100% duty
cycle due to thermal restrictions or power consumption), while a value of 0
indicates that the component is fully off.

Since perceived light intensity is logarithmic with the duty cycle, it may be
desirable for the host to exponentially scale the given RGB component values
based on the desired perceived brightness. The device shall perform no such
scaling on its own.
